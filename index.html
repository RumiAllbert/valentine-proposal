<!DOCTYPE html>
<html>

<head>
    <title>My Eternal Valentine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Great Vibes', cursive;
            /* Original dark space-like background */
            background: radial-gradient(ellipse at center, #1b2735 0%, #090a0f 100%);
            transition: background 1s ease;
        }

        #canvas-container {
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff3366;
            z-index: 100;
            opacity: 0;
            animation: fadeIn 3s forwards;
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .buttons {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin-top: 2rem;
            position: relative;
        }

        button {
            background: #ff3366;
            border: none;
            padding: 1rem 2rem;
            color: white;
            border-radius: 30px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.3s;
        }

        button:hover {
            transform: scale(1.1);
        }

        #noBtn {
            background: #6a6a6a;
            transition: transform 0.3s ease-out;
        }

        #responseText {
            margin-top: 1rem;
            color: #ff3366;
            animation: shake 0.5s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(10px);
            }

            75% {
                transform: translateX(-10px);
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
</head>

<body>
    <div id="canvas-container"></div>
    <div class="message">
        <h1 style="font-size: 4em">Will you be my valentines? <br>üåπ</h1>
        <div class="buttons">
            <button onclick="celebrate()">Yes ‚ô•Ô∏è</button>
            <button id="noBtn" onmouseover="moveNoButton()" onclick="playfulReject()">No</button>
        </div>
        <p id="responseText" style="display: none; font-size: 1.5em"></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, particles;
        let mouseX = 0, mouseY = 0;
        let mousePos = new THREE.Vector2();
        let floatingHearts = [];
        // Globals to track celebration mode and rotation.
        let celebrationStarted = false;
        let celebrationRotation = 0;

        function init() {
            // Setup Scene and Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Renderer with alpha so that the CSS background shows through
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Constellation particles (with slight purple color).
            createHearts();

            // Create many floating 3D heart objects.
            createFloatingHearts();

            // Lighting for the scene.
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xff3366, 1);
            pointLight.position.set(5, 3, 5);
            scene.add(pointLight);

            camera.position.z = 5;

            // Track mouse moves for parallax.
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
                mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;
                moveNoButton();
            });

            window.addEventListener('resize', onWindowResize);
        }

        // Static constellation particle system with a slight purple hue.
        function createHearts() {
            const particlesGeometry = new THREE.BufferGeometry();
            const count = 1000;
            const posArray = new Float32Array(count * 3);
            for (let i = 0; i < count * 3; i += 3) {
                posArray[i] = (Math.random() - 0.5) * 10;
                posArray[i + 1] = (Math.random() - 0.5) * 10;
                posArray[i + 2] = (Math.random() - 0.5) * 10;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.01,
                color: 0x9a4dff,
                transparent: true,
                opacity: 0.9
            });
            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }

        // Create floating 3D heart objects (smaller and with pulsating color).
        function createFloatingHearts() {
            let heartShape = new THREE.Shape();
            heartShape.moveTo(0, 0);
            heartShape.bezierCurveTo(0, 0, 0.5, 1, 1, 0);
            heartShape.bezierCurveTo(1.5, -1, 0.5, -1.5, 0, -2.5);
            heartShape.bezierCurveTo(-0.5, -1.5, -1.5, -1, -1, 0);
            heartShape.bezierCurveTo(-0.5, 1, 0, 0, 0, 0);

            const extrudeSettings = {
                depth: 0.2,
                bevelEnabled: true,
                bevelSize: 0.1,
                bevelThickness: 0.1,
                bevelSegments: 2
            };

            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);

            const numHearts = 50;
            for (let i = 0; i < numHearts; i++) {
                let material = new THREE.MeshPhongMaterial({
                    color: 0xff3366,
                    emissive: 0xff6699,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                let heartMesh = new THREE.Mesh(geometry, material);
                const scaleFactor = 0.3;
                heartMesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                heartMesh.position.x = (Math.random() - 0.5) * 10;
                heartMesh.position.y = (Math.random() - 0.5) * 10;
                heartMesh.position.z = (Math.random() - 0.5) * 10;
                heartMesh.rotation.x = Math.random() * Math.PI;
                heartMesh.rotation.y = Math.random() * Math.PI;
                heartMesh.userData.phase = Math.random() * Math.PI * 2;
                floatingHearts.push(heartMesh);
                scene.add(heartMesh);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // "No" button moves faster away from the mouse while still being clickable.
        function moveNoButton() {
            const noBtn = document.getElementById('noBtn');
            const rect = noBtn.getBoundingClientRect();
            const btnCenterX = rect.left + rect.width / 2;
            const btnCenterY = rect.top + rect.height / 2;

            const distance = Math.sqrt(
                Math.pow(mouseX - btnCenterX, 2) +
                Math.pow(mouseY - btnCenterY, 2)
            );
            if (distance < 200) {
                const angle = Math.atan2(mouseY - btnCenterY, mouseX - btnCenterX);
                const moveDistance = 200 - distance;
                const newX = Math.cos(angle + Math.PI) * moveDistance * 0.2;
                const newY = Math.sin(angle + Math.PI) * moveDistance * 0.2;
                noBtn.style.transform = `translate(${newX}px, ${newY}px)`;
            } else {
                noBtn.style.transform = 'translate(0, 0)';
            }
        }

        function playfulReject() {
            const responses = [
                "Really? Try again!",
                "You can't resist!",
                "Not an option!",
                "I know you want to say Yes!",
                "Nice try! üòâ"
            ];
            const responseText = document.getElementById('responseText');
            responseText.style.display = 'block';
            responseText.textContent = responses[Math.floor(Math.random() * responses.length)];
        }

        // When the "Yes ‚ô•Ô∏è" button is clicked:
        // - Update the message with a coupon note in a more readable font.
        // - Change the background.
        // - Activate celebration mode for the hearts to form a heart shape.
        function celebrate() {
            // Update the overlay message to a coupon message with a new font.
            const messageEl = document.querySelector('.message');
            messageEl.innerHTML = `
                <p style="font-size: 1.5em; font-family: 'Times New Roman', serif; color:#ff3366;">
                    Hi; I'm sorry we can't spend this valentines together :(  <br>
                    but i promise i will make it up to you. ü´°
                    <br>
                    <br>
                    You can save this as a coupon for a later day
                    <br>
                    <br>
                    te quiero mi amor ‚ô•Ô∏è
                </p>
                <br/>
                <a href="coupon.png" download="ValentineCoupon.png">
                    <button style="background: #ff3366; border: none; padding: 1rem 2rem; color: white; border-radius: 30px; font-size: 1.2rem; cursor: pointer;">
                        Download
                    </button>
                </a>
            `;
            // Change background.
            document.body.style.background = "radial-gradient(ellipse at center, #ffdde1 0%, #ee9ca7 100%)";
            // Activate celebration mode.
            celebrationStarted = true;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Parallax effect.
            const targetX = (mouseX / window.innerWidth - 0.5) * 4;
            const targetY = -(mouseY / window.innerHeight - 0.5) * 4;
            camera.position.x += (targetX - camera.position.x) * 0.02;
            camera.position.y += (targetY - camera.position.y) * 0.02;
            camera.lookAt(scene.position);

            if (celebrationStarted) {
                // Slower rotation and slower movement: hearts form a heart shape.
                celebrationRotation += 0.002;
                let num = floatingHearts.length;
                const shapeScale = 0.2; // scale factor for heart formation
                floatingHearts.forEach((heart, index) => {
                    let t = (index / num) * 2 * Math.PI;
                    let angle = t + celebrationRotation;
                    // Using the classic parametric heart curve:
                    let targetX = shapeScale * (16 * Math.pow(Math.sin(angle), 3));
                    let targetY = shapeScale * ((13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle)) + 4);
                    let target = new THREE.Vector3(targetX, targetY, 0);
                    // Use a lower lerp factor (0.01) for slower movement.
                    heart.position.lerp(target, 0.007);
                    // Optionally fix rotations.
                    heart.rotation.x = 0;
                    heart.rotation.y = 0;
                });
            } else {
                // Regular floating hearts animation.
                floatingHearts.forEach((heart) => {
                    heart.rotation.x += 0.005;
                    heart.rotation.y += 0.005;
                    heart.position.y += 0.001 * Math.sin(Date.now() * 0.001 + heart.position.x);
                    let baseHue = 0;
                    let offset = 0.05 * Math.sin(Date.now() * 0.002 + heart.userData.phase);
                    let hue = baseHue + offset;
                    if (hue < 0) hue += 1;
                    heart.material.color.setHSL(hue, 0.7, 0.5);
                });
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>

</html>